<div style="max-width: 1170px; margin:0 auto;">
    <h1>Code</h1>
    <h2>Model</h2>
    <p>Corresponds to a db entity</p>
    <h2>Viewmodel</h2>
    <p>Object responsible for part of a view, usually has observable proeprties, it doesn't matter how it's created, as long as it's a object. Should be nested in larger applications</p>
    <pre>
var v = {
  prop: ko.observable(false),
  propArray: ko.observableArray()
}
</pre>
    <p>Good construct for creating viewmodels:</p>
    <pre>
var myVM = (function(){
  var privateFunction = function(){}; //can only be accessed inside this scope, meaning that it can be used for creating private variables/functions for a vm.
  var me = {
  };
  return me;
})();
</pre>
    <h2>Observable</h2>
    <p>
        variable/property that contains a single value, be it an object, simple type or function, and informs any listener when it changes. Only informs when it changes itself,
        not when its property changes, unless they're observable to.
    </p>
    <pre>var v = ko.observable(false);</pre>
    <h2>ObservableArray</h2>
    <p>An observable that contains an array and informs when it's modified (pushed to, items removed etc)</p>
    <pre>var v = ko.observableArray(myArrayOrNothing);</pre>
    <h2>Computed</h2>
    <p>
        A computed is meant to return a value of any kind (simple type, object, array) based on other observables. This will notify any listener that it should reevaluate whenever one of the observables used in it changes.
        A computed can not be created inside of or before a literal if it uses any properties of that literal. This is because the function you put into a computed will be executed as soon as it's created, resulting in a null reference for the literal object.
    </p>
    <pre>
var me = {
  firstName: ko.observable('first name'),
  lastName: ko.observable('last name')
};
me.fullName = ko.computed(function(){
  return me.firstName() + ' ' + me.lastName();
});
</pre>
    <h2>Subscribe</h2>
    <p>Used when you need code to react when a observable changes</p>
    <pre>
var v = ko.observable(false);
v.subscribe(function(newVal){
  alert('value of v is ' + newVal);
});
</pre>
    <h2>Applybindings</h2>
    <p>This is what tells your view to start listening to your VM. This should only be applied once, something is very wrong in your bindings if you have to apply it again. It can however be used to apply different "main" VMs to different html elements if you want only parts of your page to use knockout.</p>
    <pre>ko.applyBindings(vm,htmlNode(optional));</pre>
    <h1>View</h1>
    <h2>Data-bind</h2>
    <p>
        Put data-bind attribute on element that should be binding to a vm. The data bind attribute takes the form of a javascript object literal and can use properties such as text,html,click,foreach,css,value(inputs) (class)
    </p>
    <h3>The text binding</h3>
    <p>The text binding will write the value of the property that it's bound to, or you can concatenate anything you want, concatenating text will work as a computed, it will re-write the text if any observable changes. Notice that we have to execute observables when concatenating but not when using a single observable</p>
        <pre>
&lt;p data-bind="text: oneObservable() + ' other text ' + secondObservable()"&gt; Concatenated text &lt;/p&gt;
&lt;p data-bind="text: nameOfObservable}"&gt; Simple observable value &lt;/p&gt;
    </pre>
    <h3>The value binding</h3>
    <p> The value binding works as the text binding but in a more obvious two-way fashion. It does however not support writing back to concatenated text.</p>
    <pre>
&lt;input type="text" data-bind="value: oneObservable" /&gt;
</pre>
    <h3>The click binding</h3>
    <p>The click binding is a proeprty of the data-bind attribute that specifies a handler for a click on the element, this could be bound to a function on your VM/Model or be a inline function. Remember not to write () after the function name if you bind to a function on your VM, it will execute the function when parsing if you forget this.</p>
    <pre>
&lt;a href="javascript:;" data-bind="click: function(){ alert('I'm inline');}"&gt; Click me inline &lt;/a&gt;
&lt;a href="javascript:;" data-bind="click: nameOfFunctionOnVM"&gt; Click me, on VM &lt;/a&gt;
    </pre>
    <h1>Put it together</h1>
    <p>Model constructor:</p>
    <pre>
function Transaction(){
  this.value = ko.observable()
}
</pre>
    <p>Viewmodel:</p>
    <pre>
var transactionsVM = {
  transactions: ko.observableArray(),
  addTransaction: function(transaction){
    transactionsVM.transactions.push(transaction); //We can push directly to the observableArray without executing it first
  }
};
//Has to be added after literal since it will be evaluated on creation and we reference the literal itself.
transactionsVM.totalValue = ko.computed(function(){
  var value = 0;
  //There are helper utils for working with/iterating over/filtering arrays
  for(var i = 0; i < transactionsVM.transations().length; i++){ //We have to execute transactions to get the underlaying array
    value += transactionsVM.transactions()[i].value;
  }
  return value;
});
</pre>
    <p>View:</p>
    <pre>
&lt;ul data-bind="foreach: transactions"&gt;
  &lt;li data-bind="text: value"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-bind="text: totalValue"&lt;/p&gt;
</pre>
    <p>Applying magic:</p>
    <pre>
ko.applyBindings(transactionsVM);
</pre>
    <p>
        This creates a view that lists an array of transactions and a row with total value of all the transactions
    </p>

    <h1>Do it yourself</h1>
    <p>
        This project is setup with a MVC View (Index.cshtml) located in /Areas/Admin/Views/Main. You will reach this view by starting the project and appending /admin to the URL.
        You can create your KnockoutJS views in this file, it also contains references to necessary framework/libraries that you will need. There is also a reference to adminVM located in /Scripts/VMs where you can start to write
        your application logic. You will find the .less file for this project in /Content and you can continue to work here, or create a new .css file and add it to the "head" section of the index.cshtml file.
    </p>
    <p>You won't have to do anything ASP.NET MVC to work with knockout.</p>

    <h1>Documentation</h1>
    <p>Debug <a href="http://www.knockmeout.net/2013/06/knockout-debugging-strategies-plugin.html">http://www.knockmeout.net/2013/06/knockout-debugging-strategies-plugin.html</a></p>
    <p>Documentation <a href="http://knockoutjs.com/documentation/introduction.html">http://knockoutjs.com/documentation/introduction.html</a></p>
</div>